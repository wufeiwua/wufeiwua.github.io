{"posts":[{"title":"什么是补码","content":"补码仅仅是一种编码，好处是可以用加法来实现减法的操作，和原码、反码没啥太大的关系 二进制 在十进制中，可以用 0∼90\\sim90∼9 来表示有一数，16 记为 16，权重为 10n10^n10n 16 表示 1∗101+6∗100=161*10^1 + 6 * 10^0 = 161∗101+6∗100=16 在16进制中，可以用0∼F0\\sim F0∼F 来表示一个数，16 记为 0x10，权重为 16n16^n16n 0x10 表示 1∗161+0∗160=16[10]1*16^1 + 0*16^0 = 16_{[10]}1∗161+0∗160=16[10]​ 在二进制中，只能用 0,10, 10,1 来表示一个数，那么 16 就记为10000 ， 权重是 2n2^n2n 10000 表示 1∗24+0∗23+0∗22+0∗21+0∗20=16[10]1*2^4+0*2^3+0*2^2+0*2^1+0*2^0=16_{[10]}1∗24+0∗23+0∗22+0∗21+0∗20=16[10]​ 于是我们就有了一个新的计数方法，二进制: 十进制 二进制 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 加法 但是光有计数还不够，我们还需要有计算，二进制中封二进一，假如我们自己实现了一个全加器： 010[2]+100[2]=110[2]=6[10]010_{[2]} + 100_{[2]} = 110_{[2]} = 6_{[10]}010[2]​+100[2]​=110[2]​=6[10]​ 011[2]+001[2]=100[2]=4[10]011_{[2]} + 001_{[2]} = 100_{[2]} = 4_{[10]}011[2]​+001[2]​=100[2]​=4[10]​ 减法 有了加法器，那还得有一个减法器，假如我们又自己实现了减法器（现代计算机没有减法器，暂时先忘掉这个，后面我会讲怎么用加法实现减法）： 001[2]−101[2]=−100[2]=−4[10]001_{[2]} - 101_{[2]} = -100_{[2]} = -4_{[10]}001[2]​−101[2]​=−100[2]​=−4[10]​ 没啥问题，但是出现了一个负数。可以计算机中只有 1 和 0 ，没有我们日常使用的 +,-号，怎么去表示负数 负数 正如我们数学中约定的 +和 -来表示一个数的正负一样，于是我们决定使用其中的一个符号来表示符号的 + 和 - ，那就用最高位来表示吧。0 表示正，1 表示负 十进制 二进制【使用正负号】 二进制【使用0、1代表正负号】 +0 +00 000 +1 +01 001 +2 +10 010 +3 +11 011 -0 - 00 100 -1 - 01 101 -2 - 10 110 -3 - 11 111 现在我们的可计数示范围由0∼70 \\sim 70∼7 变成了−3∼+3-3 \\sim +3−3∼+3 注意：区别与网上其他说法，最高位是符号位，表示的是正和负没错，但是我们现在有减法器，计算的时候符号位可以特殊处理，也请先忘掉加法实现减法的结论 假如计算机有+,-号，先我们的减法器验证一下： 1−3=(+01)−(+11)=(+01[2])−(+11[2])=−∣11[2]−01[2]∣=−10[2]=−2[10]\\begin{aligned} &amp; 1-3 \\\\ &amp; = (+01) - (+11) \\\\ &amp; =(+01_{[2]}) - (+11_{[2]}) \\\\ &amp; = -|11_{[2]}-01_{[2]}| \\\\ &amp; = -10_{[2]} \\\\ &amp; = -2_{[10]} \\end{aligned} ​1−3=(+01)−(+11)=(+01[2]​)−(+11[2]​)=−∣11[2]​−01[2]​∣=−10[2]​=−2[10]​​ 此时用我们约定的符号来替换正负号， 负号换成 1 ，正号换成 0 (001[2])−(011[2])=−∣11[2]−01[2]∣=−10[2]=110[2]=−2[10]\\begin{aligned} &amp; (001_{[2]}) - (011_{[2]}) \\\\ &amp; = -|11_{[2]}-01_{[2]}| \\\\ &amp; = -10_{[2]} = 110_{[2]} \\\\ &amp; = -2_{[10]} \\end{aligned} ​(001[2]​)−(011[2]​)=−∣11[2]​−01[2]​∣=−10[2]​=110[2]​=−2[10]​​ 我们知道 X−Y=X+(−Y)X - Y = X + (-Y)X−Y=X+(−Y)， 所以上面的运算等价 ： (001[2])−(011[2])=001[2]+111[2]=−∣11[2]−01[2]∣=110[2]=−2[10]\\begin{aligned} &amp; (001_{[2]}) - (011_{[2]}) \\\\ &amp; = 001_{[2]} + 111_{[2]} \\\\ &amp; = -|11_{[2]} - 01_{[2]}| \\\\ &amp; = 110_{[2]} \\\\ &amp; = -2_{[10]} \\\\ \\end{aligned} ​(001[2]​)−(011[2]​)=001[2]​+111[2]​=−∣11[2]​−01[2]​∣=110[2]​=−2[10]​​ 注意我们有减法器，这里我们的最高位此时是符号位，符号会被提出来，并不会参与运算 再次注意：区别与网上其他说法，最高位是符号位，表示的是正和负，我们现在有减法器，计算的时候符号位可以特殊处理，也请先忘掉加法实现减法的结论 比如我们十进制计算 1 - 3 = 1 + (-3)， 当一个较小数减去一个较大数的时候， 我们一般步骤是用大数减去小数取绝对值，然后结果取其相反数 例如我们平时计算 1- 3 = 1 + (-3): 1−3=1+(−3)=−∣3−1∣=−∣2∣=−2\\begin{aligned} &amp; 1 - 3 \\\\ &amp; = 1 + (-3) \\\\ &amp; = - | 3 -1 | \\\\ &amp; = - |2| \\\\ &amp; = -2 \\end{aligned} ​1−3=1+(−3)=−∣3−1∣=−∣2∣=−2​ 那么二进制减法器也一样的，最高位的符号位也是特殊处理，提出来再计算的： 001−011=001+(111)=−∣11−01∣=−∣10∣=−10=110\\begin{aligned} &amp; 001 - 011 \\\\ &amp; = 001 + (111) \\\\ &amp; = - |11 - 01| \\\\ &amp; = - |10| \\\\ &amp; = -10 \\\\ &amp; = 110 \\\\ \\end{aligned} ​001−011=001+(111)=−∣11−01∣=−∣10∣=−10=110​ 上面这种编码方式我们取一个名字，就叫 原码。 加法和减法以及符号都搞定了，不过我们需要实现一个减法器才能计算，而且处理符号也比较麻烦，有没有可能用加法实现减法，当然可以！ 模和同余 数论中的重要概念。给定一个正整数，如果两个整数a和b，满足 a−ba-ba−b 能够被 mmm 整除，即 a−bm\\frac{a - b}{m}ma−b​ 得到一个整数， 那么就称整数a与b对模m同余，记作 a≡b(mod m)a \\equiv b (mod\\;m)a≡b(modm)。 对模m同余是整数的一个等价关系。 “模”是指一个计量系统的计数范围，超出这个范围后就会产生溢出，溢出的部分会被直接舍去。例如时钟的计量范围是0-11（1-12），模=12 例如图中这样一个线段围成的圆，计数范围是 0 ~ 7 ，模 m = 8。 假如我们现在所处的位置在 1 的位置上，我们要走到 0 这个位置，我们有两种方式 退 1 步 前进 7 步 (因为模是8，只能表示到 0 ~ 7 ，8 就是 0 ，产生溢出，一个新的轮回开始了) 1−1=1+7=0⇒−1≡+7(mod8)1 - 1 = 1 + 7 = 0 \\Rightarrow -1 \\equiv +7 (mod 8) 1−1=1+7=0⇒−1≡+7(mod8) 称为+7 是 -1 以 8 为模的补数 也就是说在模为 8 的时候，+7 和 -1 是等价的 同理，假如我们所处 2 的位置上，我们要走到 0 这个位置，也有两种方式： 退 2 步 前进 6 步 2−2=2+6=0⇒−2≡+6(mod8)2-2 = 2 + 6 = 0 \\Rightarrow -2 \\equiv +6 (mod 8) 2−2=2+6=0⇒−2≡+6(mod8) 称为+6 是 -2 以 8 为模的补数 也就是说在模为 8 的时候，+6 和 -2 是等价的 由此可见在模确定的情况下，减去一个数可以由加上一个正数替代，所以一个负数可以用一个正数来表示 补数 我们知道在十进制中，如果两个数字的和为 10n10^n10n ，那么我们称这两个数互为补数。 例如 1 + 9 = 10 , 2 + 8 = 10, 3 + 7 = 10, 54 + 46 = 100 称 9 是 1 的补数， 8 是 2 的补数, 54 是 46 的补数 那么对应到二进制中，也是一样的，如果两个数的和为 2n2^n2n ，我们称这两个数互为补数，叫做 2 的补数(2's-compelment) 还是以这个图为例子，由上可知我们模为8，如果我们处于 011[2]011_{[2]}011[2]​ 的位置，想要到 000[2]000_{[2]}000[2]​ 的位置有两种方式 退 3 步 进 5 步 十进制： 3[10]−3[10]=3[10]+5[10]=0[10]⇒−3[2]≡+5[2](mod8)\\begin{aligned} &amp; 3_{[10]} - 3_{[10]} \\\\ &amp; = 3_{[10]} + 5_{[10]} \\\\ &amp; = 0_{[10]} \\\\ &amp; \\Rightarrow - 3_{[2]} \\equiv + 5_{[2]} (mod 8) \\\\ \\end{aligned} ​3[10]​−3[10]​=3[10]​+5[10]​=0[10]​⇒−3[2]​≡+5[2]​(mod8)​ 二进制： 011[2]−011[2]=011[2]+101[2]=000[2]⇒−011[2]≡+101[2](mod8)\\begin{aligned} &amp; 011_{[2]} - 011_{[2]} \\\\ &amp; = 011_{[2]} + 101_{[2]} \\\\ &amp; = 000_{[2]} \\\\ &amp; \\Rightarrow - 011_{[2]} \\equiv + 101_{[2]} (mod 8) \\end{aligned} ​011[2]​−011[2]​=011[2]​+101[2]​=000[2]​⇒−011[2]​≡+101[2]​(mod8)​ 我们说，+101[2]+ 101_{[2]}+101[2]​ 是 −011[2]- 011_{[2]}−011[2]​ 以 8 为模的补数 于是我们得出一个结论： 一个负数可用其正补数来代替，而这个正补数可以用模加上负数本身来得到。 一个正数和一个负数互为补数时，两数的绝对值之和为模 由上面的推导我们知道: −1≡+7(mod8)-1 \\equiv +7 (mod 8) −1≡+7(mod8) −2≡+6(mod8)-2 \\equiv +6 (mod 8) −2≡+6(mod8) −3≡+5(mod8)-3 \\equiv + 5 (mod 8) −3≡+5(mod8) −4≡+4(mod8)-4 \\equiv +4 (mod 8) −4≡+4(mod8) 0 具有特殊性，如果我们处于0 的位置，想要到0 的位置有两种方式： 退 0 步，进 0 步。也就是不动 进 8 步 −0≡+8(mod8)⇔0≡0(mod8)-0 \\equiv +8 (mod 8)\\Leftrightarrow 0 \\equiv 0 (mod 8) −0≡+8(mod8)⇔0≡0(mod8) 当然在 模为 8 的计数范围内，我们也没法表示 8 这个数字，8 等于 0，于是就有： −0≡+8(mod8)⇔+0≡+8(mod8)⇔−0≡+0(mod8)-0 \\equiv +8 (mod 8)\\Leftrightarrow +0 \\equiv +8 (mod 8)\\Leftrightarrow -0 \\equiv +0 (mod 8) −0≡+8(mod8)⇔+0≡+8(mod8)⇔−0≡+0(mod8) 既然 +0 和 -0 等价，就都用0来表示了，消除了 +0 和 -0 的歧义，完善一下我们的图： 根据上面的结论和推导我们又得出一张表： 十进制【原码】 二进制【补】 十进制【补】 二进制【原码】 +0 000 0 000 +1 001 1 001 +2 010 2 010 +3 011 3 011 -4 100 4 -3 101 5 111 -2 110 6 110 -1 111 7 101 关于 4 到底是 + 4 还是 -4 ，其实从补数角度来说都可以，不影响计算结果。 但是我们人为约定，二进制最高位表示符号，为了统一，所以 4 表示 - 4 而且这个和权重有关系后面会讲到 现在我们的可计数范围变成了−4∼+3-4\\sim+3−4∼+3，即 −2n∼2n−1(n=3)-2^n \\sim 2^n -1(n = 3)−2n∼2n−1(n=3) 看起来不错，这样貌似我们就能实现用加法来计算减法了，验证一下 还是以下面的式子为例： 1−3=1+(−3)1 - 3 = 1 + (-3) 1−3=1+(−3) 001[2补]+101[2补]=110[2补]=6[10补]≡−2[10原](mod8)001_{[2补]} + 101_{[2补]} = 110_{[2补]} = 6_{[10补]} \\equiv -2_{[10原]}(mod 8) 001[2补]​+101[2补]​=110[2补]​=6[10补]​≡−2[10原]​(mod8) 此时可以发现，用加法实现减法的操作，而且我们没有约定什么最高位为符号位，只是用一个正数来表示一个对应的负数而已，比如：5 表示 -3，6 表示 -2 我们需要注意，用补数计算的结果也是补数 上面的这种编码方式取个名字吧，补数补数，干脆就叫做 补码 关于反码 反码这个东西就是反计算机的，人类为了计算过程不反人类搞了这么一个中间产物，因为在人类计算原码到补码的过程中，发现的一个神奇的现象： 一个负数的补码正好是其绝对值的原码各位取反再加一 一个正数的补码正好就是其本身 比如 - 3 的补码是 101 ，计算过程是用模减去-3的绝对值，或者用模， mod - |-3|，我们例子中的模是 8 （即二进制的： 1000），所以 - 3 的补码：8 - 3 = 5 1000[原]−∣111[原]∣=1000[原]−011[原]=101[补]1000_{[原]} - |111_{[原]}| = 1000_{[原]} - 011_{[原]} = 101_{[补]} 1000[原]​−∣111[原]​∣=1000[原]​−011[原]​=101[补]​ 1000 - 011 而我们最多只能表示 3 位，无法表示 1000 ，所以用 111 + 1 表示，则 1000[原]−∣111[原]∣=111[原]−011[原]+1[原]1000_{[原]} - |111_{[原]}| = 111_{[原]} - 011_{[原]} + 1_{[原]} 1000[原]​−∣111[原]​∣=111[原]​−011[原]​+1[原]​ 计算过程就是所谓的负数的补码等于其原码除符号位不变，其余各位取反 + 1 ，而各位取反的结果就叫做反码(1's compelment)。所以都是碰巧而已，对应到其他进制的补码可就不是取反+1了，后面会讲到。 关于补码 补码其实就是一种编码方式，好处在于可以使用加法来实现减法的操作，和原码、反码没啥太大的关系，仅仅就是一种编码，硬要说有啥关系，那就是我们人类计算过程需要用原码和补码来方便我们人类的计算和识别。其实计算方式还有另外一种计算补码的方式 因为我们约定了最高位表示符号，那么我们就相当于给其赋予了负权重 例如: 111[2]=−1∗22+1∗21+1∗20=−4+2+1=−1111_{[2]} = -1*2^2 + 1*2^1 + 1*2^0 = -4 + 2 + 1 = -1 111[2]​=−1∗22+1∗21+1∗20=−4+2+1=−1 110[2]=−1∗22+1∗21+0∗20=−4+2+0=−2110_{[2]} = -1*2^2 + 1*2^1 + 0*2^0 = -4 + 2 + 0 = -2 110[2]​=−1∗22+1∗21+0∗20=−4+2+0=−2 101[2]=−1∗22+0∗21+1∗20=−4+0+1=−3101_{[2]} = -1*2^2 + 0*2^1 + 1*2^0 = -4 + 0 + 1 = -3 101[2]​=−1∗22+0∗21+1∗20=−4+0+1=−3 100[2]=−1∗22+0∗21+0∗20=−4+0+0=−4100_{[2]} = -1*2^2 + 0*2^1 + 0*2^0 = -4 + 0 + 0 = -4 100[2]​=−1∗22+0∗21+0∗20=−4+0+0=−4 010[2]=−0∗22+1∗21+1∗20=−0+2+0=2010_{[2]} = -0*2^2 + 1*2^1 + 1*2^0 = -0 + 2 + 0 = 2 010[2]​=−0∗22+1∗21+1∗20=−0+2+0=2 011[2]=−0∗22+1∗21+1∗20=−0+2+1=3011_{[2]} = -0*2^2 + 1*2^1 + 1*2^0 = -0 + 2 + 1 = 3 011[2]​=−0∗22+1∗21+1∗20=−0+2+1=3 扩展一下10进制补码 二进制中，我们可以推导出： 2n−X=Y⇒−X≡Y(mod 2n)2^n -X = Y \\Rightarrow -X \\equiv Y (mod \\; 2^n) 2n−X=Y⇒−X≡Y(mod2n) 称为 2's-compelment。其实扩展到任意数字N，关于其NwN^wNw的补数 一样适用，可以叫做 N's-compelment， 即： Nw−X=Y⇒−X≡Y(mod Nw)N^w -X = Y \\Rightarrow -X \\equiv Y (mod \\; N^w) Nw−X=Y⇒−X≡Y(modNw) 现在假如我们的世界陷入了只能计算1位数加法的混沌之中，1 + 9 = 10 ，2 + 8 = 10 这种，会产生溢出等于 0 。 而 4+7 = 11 这种，会产生溢出等于1。 现在我们只能使用0∼90\\sim90∼9这几个数字了，且失去了正号和负号。（对应计算机的二进制世界，只有0和1，没有正负符号，而且会产生溢出）。 那么我们如何表示负数以及计算减法呢 在这个世界中，我们知道以下规则： 模是 10 一个负数可以由一个正数来表示(模确定的情况下，其的正补数) 减去一个正数等于加上这个数的相反数（负数） 由于没有了负号，于是聪明的我们决定将0∼90\\sim90∼9十个数字分成两组，一半表示正，一半表示负。 不过这样我们能表示的范围就变小了，变成了 −5∼4-5\\sim4−5∼4，超过这个范围的数我们没法再表示 规则1：模是 10 规则2：一个负数可以由一个正数来表示 由： 101−X=Y⇒−X≡Y(mod 101)10^1 -X = Y \\Rightarrow -X \\equiv Y (mod \\; 10^1) 101−X=Y⇒−X≡Y(mod101) 那么我们可以知道 ： 10−1=9≡−1(mod 10)10 - 1 = 9 \\equiv-1(mod\\;10) 10−1=9≡−1(mod10) 10−2=8≡−2(mod 10)10 - 2 = 8 \\equiv-2(mod\\;10) 10−2=8≡−2(mod10) 10−3=7≡−3(mod 10)10 - 3 = 7 \\equiv-3(mod\\;10) 10−3=7≡−3(mod10) 10−4=6≡−4(mod 10)10 - 4 = 6 \\equiv-4(mod\\;10) 10−4=6≡−4(mod10) 10−5=5≡−5(mod 10)10 - 5 = 5 \\equiv-5(mod\\;10) 10−5=5≡−5(mod10) 5 表示+5 还是 -5， 完全是我们人为约定的，就像前面二进制中 100 表示 - 4 一样，那只是个计数的符号而已 我们称这种新的计数方称之为 10 的补数(10's-compelment)，或者直接叫做补码，于是我们可以得出一张对应的关系表： 十进制补码 十进制原码 0 0 1 1 2 2 3 3 4 4 5 -5 6 -4 7 -3 8 -2 9 -1 我们可以用补码来实现计算如下式子 ： 3−4=3+(−4)3 - 4 = 3 +(-4)3−4=3+(−4): 3 的补码是 3， -4 的补码是 6。 3[原]+(−4[原])=3[补]+6[补]=9[补]=−1[原]3_{[原]} + (- 4_{[原]}) = 3_{[补]} + 6_{[补]} = 9_{[补]} = -1_{[原]} 3[原]​+(−4[原]​)=3[补]​+6[补]​=9[补]​=−1[原]​ 补码，原来如此！ ","link":"https://lambdaxyz.xyz/post/bu-ma-de-ben-zhi/"},{"title":"Java 使用 `commons-math3` 的线性和非线性拟合实例，带效果图","content":"Java 使用 Apache commons-math 工具实现线性拟合以及非线性拟合的例子 例子查看 GitHub Gitee 运行src/main/java/org/wfw/chart/Main.java 即可查看效果 src/main/java/org/wfw/math 包下是简单的使用 新增了 springboot web 实例，或者查看在线例子 版本说明 JDK:1.8 commons-math:3.6.1 一些基础知识 线性：两个变量之间存在一次方函数关系，就称它们之间存在线性关系。也就是如下的函数： f(x)=kx+bf(x)=kx+b f(x)=kx+b 非线性：除了线性其他的都是非线性，例如： f(x)=exf(x)=e^x f(x)=ex 矩阵：矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，可以理解为平面或者空间的坐标点。 看大佬怎么说之&gt;&gt; B站-线性代数的本质 - 系列合集 微分、积分：互为逆过程，一句话概括，微分就是求导，求某个点的极小变化量的斜率。积分是求一些列变化点的和，几何意义是面积 看大佬怎么说之&gt;&gt; B站-微积分的本质 - 系列合集 拟合：形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来的过程。找到一条最符合这些散点的曲线，使得尽可能多的落在曲线上。常用的方法是最小二乘法。也就是最小二乘问题 添加依赖 Maven 中添加依赖 &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-math3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; 如果你是 Gradle // https://mvnrepository.com/artifact/org.apache.commons/commons-math3 compile group: 'org.apache.commons', name: 'commons-math3', version: '3.6.1' 如何使用和验证 假设函数已知 根据函数并添加随机数R生成一系列散点数据（蓝色） 进行拟合，根据拟合结果生成拟合曲线 对比结果曲线（绿色）和散点曲线 例如： f(x)=2x+3f(x) = 2x + 3 f(x)=2x+3 首先根绝函数生成 xxx 取任意实数时的以及所对应的 f(x)f(x)f(x) 得到数据集 xyxyxy f(x,y)=(0,3)∗R,(1,5)∗R,(2,7)∗R...(n,2n+3)∗Rf(x,y) = (0,3)*R, (1,5)*R, (2,7)*R...(n,2n+3)*R f(x,y)=(0,3)∗R,(1,5)∗R,(2,7)∗R...(n,2n+3)∗R 然后对这组数据进行拟合，然后和已知函数 f(x)f(x)f(x) 对比斜率 kkk 以及截距 bbb 1. 线性拟合 线性函数： f(x)=kx+bf(x) = kx + b f(x)=kx+b 假设函数为： f(x)=1.5x+0.5f(x) = 1.5x + 0.5 f(x)=1.5x+0.5 生成数据集合: /** * * y = kx + b * f(x) = 1.5x + 0.5 * * @return */ public static double[][] linearScatters() { List&lt;double[]&gt; data = new ArrayList&lt;&gt;(); for (double x = 0; x &lt;= 10; x += 0.1) { double y = 1.5 * x + 0.5; y += Math.random() * 4 - 2; // 随机数 double[] xy = {x, y}; data.add(xy); } return data.stream().toArray(double[][]::new); } 进行拟合 public static Result linearFit(double[][] data) { List&lt;double[]&gt; fitData = new ArrayList&lt;&gt;(); SimpleRegression regression = new SimpleRegression(); regression.addData(data); // 数据集 /* * RegressionResults 中是拟合的结果 * 其中重要的几个参数如下： * parameters: * 0: b * 1: k * globalFitInfo * 0: 平方误差之和, SSE * 1: 平方和, SST * 2: R 平方, RSQ * 3: 均方误差, MSE * 4: 调整后的 R 平方, adjRSQ * * */ RegressionResults results = regression.regress(); double b = results.getParameterEstimate(0); double k = results.getParameterEstimate(1); double r2 = results.getRSquared(); // 重新计算生成拟合曲线 for (double[] datum : data) { double[] xy = {datum[0], k * datum[0] + b}; fitData.add(xy); } StringBuilder func = new StringBuilder(); func.append(&quot;f(x) =&quot;); func.append(b &gt;= 0 ? &quot; &quot; : &quot; - &quot;); func.append(Math.abs(b)); func.append(k &gt; 0 ? &quot; + &quot; : &quot; - &quot;); func.append(Math.abs(k)); func.append(&quot;x&quot;); return new Result(fitData.stream().toArray(double[][]::new), func.toString()); } 拟合效果 线性拟合比较简单，主要是 SimpleRegression 类的 regress() 方法，默认使用 最小二乘法优化器 2. 非线性（曲线）拟合（一元多项式） 非线性函数 f(x)=a+bx+cx2+dx3+...+mxnf(x) = a + bx + cx^2 + dx^3 +...+ mx^n f(x)=a+bx+cx2+dx3+...+mxn 假设函数为 f(x)=1+2x+3x2f(x) = 1 + 2x + 3x^2 f(x)=1+2x+3x2 生成数据集合: /** * * f(x) = 1 + 2x + 3x^2 * * @return */ public static double[][] curveScatters() { List&lt;double[]&gt; data = new ArrayList&lt;&gt;(); for (double x = 0; x &lt;= 20; x += 1) { double y = 1 + 2 * x + 3 * x * x; y += Math.random() * 60 - 10; // 随机数 double[] xy = {x, y}; data.add(xy); } return data.stream().toArray(double[][]::new); } 进行拟合 public static Result curveFit(double[][] data) { ParametricUnivariateFunction function = new PolynomialFunction.Parametric();/*多项式函数*/ double[] guess = {1, 2, 3}; /*猜测值 依次为 常数项、1次项、二次项*/ // 初始化拟合 SimpleCurveFitter curveFitter = SimpleCurveFitter.create(function,guess); // 添加数据点 WeightedObservedPoints observedPoints = new WeightedObservedPoints(); for (double[] point : data) { observedPoints.add(point[0], point[1]); } /* * best 为拟合结果 * 依次为 常数项、1次项、二次项 * 对应 y = a + bx + cx^2 中的 a, b, c * */ double[] best = curveFitter.fit(observedPoints.toList()); /* * 根据拟合结果重新计算 * */ List&lt;double[]&gt; fitData = new ArrayList&lt;&gt;(); for (double[] datum : data) { double x = datum[0]; double y = best[0] + best[1] * x + best[2] * x * x; // y = a + bx + cx^2 double[] xy = {x, y}; fitData.add(xy); } StringBuilder func = new StringBuilder(); func.append(&quot;f(x) =&quot;); func.append(best[0] &gt; 0 ? &quot; &quot; : &quot; - &quot;); func.append(Math.abs(best[0])); func.append(best[1] &gt; 0 ? &quot; + &quot; : &quot; - &quot;); func.append(Math.abs(best[1])); func.append(&quot;x&quot;); func.append(best[2] &gt; 0 ? &quot; + &quot; : &quot; - &quot;); func.append(Math.abs(best[2])); func.append(&quot;x^2&quot;); return new Result(fitData.stream().toArray(double[][]::new), func.toString()); } 拟合效果 一元多项式曲线的拟合多了一些步骤。但是总归也是不难的。主要是 SimpleCurveFitter 类以及 ParametricUnivariateFunction 接口。 3. 自定义函数拟合（一元多项式） 总得来说，貌似线性和一元多项式都不难。不过，实际工作或者学术中，一般都是自定义的函数。 假设有一元多项式函数: f(x)=d+a−d1+(xc)bf(x) = d + \\frac{a-d}{1 + (\\frac{x}{c})^b} f(x)=d+1+(cx​)ba−d​ 需要拟合出 a,b,c,d 四个参数的值。 方法: 实现 ParametricUnivariateFunction 接口 自定义函数,实现 value 方法 解偏微分方程，实现 gradient 方法 设置需要拟合的点 调用SimpleCurveFitter#fit 方法进行拟合 不着急写代码，先看ParametricUnivariateFunction 这个接口的源码: /** * An interface representing a real function that depends on one independent * variable plus some extra parameters. * * @since 3.0 */ public interface ParametricUnivariateFunction { /** * Compute the value of the function. * 计算函数的值 * @param x Point for which the function value should be computed. * @param parameters Function parameters. * @return the value. */ double value(double x, double ... parameters); /** * Compute the gradient of the function with respect to its parameters. * 计算函数相对于某个参数的导数 * @param x Point for which the function value should be computed. * @param parameters Function parameters. * @return the value. */ double[] gradient(double x, double ... parameters); } value 方法很简单，就是说计算函数 F(x)F(x)F(x) 的值。说人话就是自定义函数的 gradient 方法为返回一个数组,其实意思就是求偏微分方程，对每一个要拟合的参数求导就行 不会偏微分方程？ 点这里 按格式输入你的方程=&gt;输入自变量=&gt;输入求导阶数(一般都是 1 阶)=&gt;计算 好了开始写代码吧，假设函数如下： f(x)=d+a−d1+(xc)bf(x) = d + \\frac{a-d}{1 + (\\frac{x}{c})^b} f(x)=d+1+(cx​)ba−d​ 自定义 MyFunction 实现 ParametricUnivariateFunction 接口： static class MyFunction implements ParametricUnivariateFunction { public double value(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; return d + ((a - d) / (1 + Math.pow(x / c, b))); } public double[] gradient(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; double[] gradients = new double[4]; double den = 1 + Math.pow(x / c, b); gradients[0] = 1 / den; // 对 a 求导 gradients[1] = -((a - d) * Math.pow(x / c, b) * Math.log(x / c)) / (den * den); // 对 b 求导 gradients[2] = (b * Math.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den); // 对 c 求导 gradients[3] = 1 - (1 / den); // 对 d 求导 return gradients; } } 生成数据散点 /** * * &lt;pre&gt; * f(x) = d + ((a - d) / (1 + Math.pow(x / c, b))) * a = 1500 * b = 0.95 * c = 65 * d = 35000 * &lt;/pre&gt; * * @return */ public static double[][] customizeFuncScatters() { MyFunction function = new MyFunction(); List&lt;double[]&gt; data = new ArrayList&lt;&gt;(); for (double x = 7; x &lt;= 10000; x *= 1.5) { double y = function.value(x, 1500, 0.95, 65, 35000); y += Math.random() * 5000 - 2000; // 随机数 double[] xy = {x, y}; data.add(xy); } return data.stream().toArray(double[][]::new); } 拟合自定义函数 public static Result customizeFuncFit(double[][] scatters) { ParametricUnivariateFunction function = new MyFunction();/*多项式函数*/ double[] guess = {1500, 0.95, 65, 35000}; /*猜测值 依次为 a b c d 。必须和 gradient 方法返回数组对应。如果不知道都设置为 1*/ // 初始化拟合 SimpleCurveFitter curveFitter = SimpleCurveFitter.create(function,guess); // 添加数据点 WeightedObservedPoints observedPoints = new WeightedObservedPoints(); for (double[] point : scatters) { observedPoints.add(point[0], point[1]); } /* * best 为拟合结果 对应 a b c d * 可能会出现无法拟合的情况 * 需要合理设置初始值 * */ double[] best = curveFitter.fit(observedPoints.toList()); double a = best[0]; double b = best[1]; double c = best[2]; double d = best[3]; // 根据拟合结果生成拟合曲线散点 List&lt;double[]&gt; fitData = new ArrayList&lt;&gt;(); for (double[] datum : scatters) { double x = datum[0]; double y = function.value(x, a, b, c, d); double[] xy = {x, y}; fitData.add(xy); } // f(x) = d + ((a - d) / (1 + Math.pow(x / c, b))) StringBuilder func = new StringBuilder(); func.append(&quot;f(x) =&quot;); func.append(d &gt; 0 ? &quot; &quot; : &quot; - &quot;); func.append(Math.abs(d)); func.append(&quot; ((&quot;); func.append(a &gt; 0 ? &quot;&quot; : &quot;-&quot;); func.append(Math.abs(a)); func.append(d &gt; 0 ? &quot; - &quot; : &quot; + &quot;); func.append(Math.abs(d)); func.append(&quot; / (1 + &quot;); func.append(&quot;(x / &quot;); func.append(c &gt; 0 ? &quot;&quot; : &quot; - &quot;); func.append(Math.abs(c)); func.append(&quot;) ^ &quot;); func.append(b &gt; 0 ? &quot; &quot; : &quot; - &quot;); func.append(Math.abs(b)); return new Result(fitData.stream().toArray(double[][]::new), func.toString()); } 拟合效果 4. 多元多项式拟合 我用的 javafx8 版本不支持 WebGL 所以无法通过按钮直接直观展示拟合效果。我用拟合前得数据和拟合后重新计算的数据进行对比 方程 f(x1,x2)=y=a+b∗x1+c∗sin(x2)f(x_1,x_2) = y = a + b * x_1 + c * sin(x_2) f(x1​,x2​)=y=a+b∗x1​+c∗sin(x2​) 4.1 构造数据 假设: a=20,b=2,c=12a = 20, b = 2, c = 12a=20,b=2,c=12 ，则函数 fff 为 f(x1,x2)=y=20+2∗x1+12∗sin(x2)f(x_1,x_2) = y = 20 + 2 * x_1 + 12 * sin(x_2)f(x1​,x2​)=y=20+2∗x1​+12∗sin(x2​) 根据这个函数构造数据 /** * 生成随机数 */ public static double[][] randomX() { List&lt;double[]&gt; data = new ArrayList&lt;&gt;(); for (double i = 0; i &lt; 10; i += 0.1) { double x1 = Math.cos(i); double x2 = Math.sin(i); data.add(new double[]{x1, x2}); } return data.stream().toArray(double[][]::new); } /** * f(x1,x2) = y = a + b * x1 + c * sin(x2) * @param arr * @return */ public static double[] randomY(double[][] arr) { if (arr != null &amp;&amp; arr.length &gt; 0) { int len = arr.length; double[] y = new double[len]; for (int i = 0; i &lt; len; i++) { // f(x1,x2) = y = 20 + x1 + 12 * sin(x2) double[] x = arr[i]; // 构造数据 y[i] = functionConstructorY(x); } return y; } return null; } /** * 已知的函数为: f(x1,x2) = y = 20 + 2 * x1 + 12 * sin(x2) * 即：f(x1,x2) = y = a + b * x1 + c * sin(x2) 中 * a = 20, b = 2, c = 12 * @param x * @return */ public static double functionConstructorY(double[] x) { double x1 = x[0], x2 = x[1]; return 20 + 2 * x1 + Math.sin(10 * x2); } 4.2 拟合 多元多项式的拟合主要用到 MultipleLinearRegression 接口，它有三个实现方式。我们选择最小二乘法的实现 OLSMultipleLinearRegression /** * 多元多项式数据 * 已知： f(x1,x2) = y = a + b * x1 + c * sin(x2) * */ public static double[][] multiVarPolyScatters() { double[][] x = randomX(); double[] y = randomY(x); OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); ols.newSampleData(y, x); // ct 拟合的常数项（系数）。对应 a,b,c double[] ct = ols.estimateRegressionParameters(); } 4.3 验证 根据上面的拟合结果重新计算 f(x1,x2)f(x_1,x_2)f(x1​,x2​) 的值 /** * f(x1,x2) = y = a + b * x1 + c * sin(x2) * @param ct 拟合的常数项（系数）。对应 a,b,c * @param x x 的值。对应 x1,x2 * @return */ public static double functionValueY(double[] ct, double[] x) { double a = ct[0], b = ct[1], c = ct[2]; double x1 = x[0], x2 = x[1]; return a + b * x1 + Math.sin(c * x2); } /** * 多元多项式数据 * 已知： f(x1,x2) = y = a + b * x1 + c * sin(x2) * @return * arr[0] 对应所有的 y 的值 * arr[1] 对应所有的 x1 的值 * arr[2] 对应所有的 x2 的值 */ public static double[][] multiVarPolyScatters() { double[][] x = randomX(); double[] y = randomY(x); OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); ols.newSampleData(y, x); // ct 即为拟合结果 double[] ct = ols.estimateRegressionParameters(); double[] valueY = new double[x.length]; for (int i = 0; i &lt; x.length; i++) { // 重新计算 y 的值。与原有构造的 y 对比 valueY[i] = functionValueY(ct, x[i]); } // 散点数据用于 Echarts 画图 double[][] data = new double[x.length][3];// x1, x2, y for (int i = 0; i &lt; valueY.length; i++) { // ==================== x1 ====== x2 ======= y ==== data[i] = new double[]{x[i][0], x[i][1], valueY[i]}; } return data; } 4.4 画图 Echarts 3D画图的工具在 https://echarts.apache.org/examples/zh/editor.html?c=line3d-orthographic&amp;gl=1 这个地方。我们将构造数据的函数改为我们的 // ... var data = []; // Parametric curve for (var t = 0; t &lt; 10; t += 0.1) { // 这里改成我们的函数。其他的都不变 var x = Math.cos(t); var y = Math.sin(t); var z = 20 + 2 * x + 12 * Math.sin(y); data.push([x, y, z]); } // ... 那可以得到这样一张图 然后我们运行 org.wfw.chart.data.MultipleLinearRegressionData#main() 方法后将得到的数据整个赋值给 data 覆盖也行。我们就得到了如下的图 拟合的结果是 $$ a = 20.01068756847646, b = 2.036022472817587, c = 10.571979017911016 $$ 和我们一开始的确定好的值也差不多 4.5 多说两句 calculateRSquared() 计算 R2R^2R2 calculateAdjustedRSquared() 计算 ajdRSQajdRSQajdRSQ ，调整后的 R2R^2R2 estimateRegressionParameters() 拟合常数项 关于 newSampleData() 方法参数的 y 和 x 样本 /** * Loads model x and y sample data, overriding any previous sample. * * Computes and caches QR decomposition of the X matrix. * @param y the [n,1] array representing the y sample * @param x the [n,k] array representing the x sample * @throws MathIllegalArgumentException if the x and y array data are not * compatible for the regression */ public void newSampleData(double[] y, double[][] x) throws MathIllegalArgumentException { validateSampleData(x, y); newYSampleData(y); newXSampleData(x); } 源码是这样的，y 就是 f(x1,x2)f(x_1,x_2)f(x1​,x2​) 的值，而 x 中的 k 代表的是 x1,x2x_1,x_2x1​,x2​​ 的值，是顺序对应的 ","link":"https://lambdaxyz.xyz/post/java-shi-yong-commons-math3-de-xian-xing-he-fei-xian-xing-ni-he-shi-li-dai-xiao-guo-tu/"}]}